# Title
Create index module

# Description
Implement the task index management for `tasks/.hod/index.json`.

Index is the **single source of truth** for task status and dependencies.
Markdown files store only Title, Description, and custom fields.

## Functionality

### IndexService

```ts
interface TaskIndexData {
  status: string;
  dependencies: string[];
}

interface IndexData {
  [taskId: string]: TaskIndexData;
}

interface IndexService {
  load(): Promise<IndexData>;
  update(taskId: string, data: TaskIndexData): Promise<void>;
  remove(taskId: string): Promise<void>;
  getNextTasks(): Promise<string[]>;  // Returns IDs of ready tasks
}
```

### Methods

- `load()` — load index.json, return {} if file doesn't exist
- `update(taskId, data)` — update status and dependencies (validation + atomic write)
- `remove(taskId)` — remove task from index (no-op if doesn't exist)
- `getNextTasks()` — return IDs of tasks ready to start (reads index from load())

### Atomic operations

`update()` uses atomic write-replace (POSIX):

```ts
const tempPath = `${indexPath}.tmp`;
await fs.unlink(tempPath).catch(() => {});
await fs.writeFile(tempPath, JSON.stringify(data, null, 2));
await fs.rename(tempPath, indexPath);  // atomic on POSIX
```

### getNextTasks logic

```ts
async getNextTasks(): Promise<string[]> {
  // 1. Load index
  const index = await this.load();

  // 2. Find ready tasks
  const ready: string[] = [];
  for (const [id, data] of Object.entries(index)) {
    // Skip if already completed
    if (data.status === 'completed') continue;

    // Check all dependencies
    const depsCompleted = data.dependencies.every(depId => {
      const dep = index[depId];
      return dep && dep.status === 'completed';
    });

    if (depsCompleted) {
      ready.push(id);
    }
  }

  // 3. Sort by ID (numeric sort)
  return sortIds(ready);
}
```

A task is ready to start if:
1. Its status `!== 'completed'`
2. All dependencies are completed (their status === `'completed'`)
3. Task exists in index

**Order:** sorted by ID (numeric, like `storage.list()`)

### index.json format

```json
{
  "1": {"status": "pending", "dependencies": []},
  "2": {"status": "completed", "dependencies": ["1"]},
  "3": {"status": "pending", "dependencies": ["1", "2"]},
  "1.1": {"status": "in_progress", "dependencies": ["1"]},
  "1.2": {"status": "pending", "dependencies": ["1", "1.1"]}
}
```

**Note:** Index is the only storage for status/deps. These fields do NOT exist in markdown.

## Error handling

```ts
class IndexLoadError extends Error {
  constructor(message: string, public cause?: Error) {
    super(message);
    this.name = 'IndexLoadError';
  }
}

class IndexWriteError extends Error {
  constructor(message: string, public cause?: Error) {
    super(message);
    this.name = 'IndexWriteError';
  }
}

class IndexCorruptionError extends Error {
  constructor(message: string, public cause?: Error) {
    super(message);
    this.name = 'IndexCorruptionError';
  }
}

class IndexValidationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'IndexValidationError';
  }
}

class CircularDependencyError extends Error {
  constructor(message: string, public cycle: string[]) {
    super(message);
    this.name = 'CircularDependencyError';
  }
}
```

### Error mapping

- `load()` with invalid JSON → `IndexCorruptionError`
- `load()` with access error → `IndexLoadError`
- `writeFile`/`rename` failures → `IndexWriteError`
- Cycle detected → `CircularDependencyError`
- Invalid ID format → `IndexValidationError`

### Data loss

**Important:** If index.json is corrupted or deleted, status and dependency data are **permanently lost**.
Users should regularly backup the `tasks/.hod/` directory.

## Validation

### update() validates:

1. **Circular dependency** — traverse graph from taskId, if cycle found → `CircularDependencyError`
2. **Self-dependency** — taskId in its own deps → `CircularDependencyError`
3. **ID format** — regex `^\d+(\.\d+)*$` (like Storage), max 50 chars
4. **ID length** — maximum 50 characters
5. **Duplicates** — auto-dedup dependencies
6. **Whitespace** — trim each dependency ID
7. **Status value** — any string (no enum, validation delegated to CLI)

**Note:** `update()` does NOT verify that dependency IDs exist in the index (bootstrap problem).

### Cycle detection algorithm

DFS with coloring (white/gray/black):
- O(V+E) complexity
- Returns cycle path for error message

## Integration

### File path

`{tasksDir}/.hod/index.json` — hardcoded within tasksDir

### Directory creation

Shared helper `ensureHodDirectory()`:
- Called from `update()` before write
- `load()` does NOT create directory
- Creates `.hod/` inside `tasksDir`

### Constructor

```ts
class IndexServiceImpl implements IndexService {
  constructor(
    private readonly tasksDir: string,
    private readonly fs: FsModule = defaultFs,
  ) {}
}
```

- Dependency injection `fs` for testing
- Resolves `tasksDir` as absolute path
- Does NOT verify `tasksDir` exists (fail-late)
- Does NOT create directories in constructor

### Exports from `src/index/index.ts`

- Interface `IndexService`
- Class `IndexServiceImpl`
- Factory `createIndexService(tasksDir: string, fs?: FsModule): IndexService`
- All error classes
- Type `IndexData`
- Type `TaskIndexData`

### Shared utility

Extract `sortIds()` from Storage to `src/utils/sort.ts`:
- Numeric sort by ID segments
- Used in `getNextTasks()` and Storage

### Concurrency

**Not supported in v1.** Documentation: multiple CLI instances → last writer wins (atomic rename). File locking is not implemented.

## Edge cases

### load()

- File doesn't exist → return `{}`
- `.hod/` doesn't exist → return `{}`
- Invalid JSON → `IndexCorruptionError`
- Empty file (`{}`) → return `{}`
- Non-object values → `IndexCorruptionError` (type validation)
- Task value not object → `IndexCorruptionError`

### update()

- Empty deps array → valid, saves `[]`
- Empty status → valid, saves as-is
- Duplicates in deps → auto-dedup
- Whitespace in deps → auto-trim
- taskId doesn't exist in index → add new entry
- Circular dependency → `CircularDependencyError` with cycle path
- Invalid ID format → `IndexValidationError`
- ID > 50 chars → `IndexValidationError`

### remove()

- taskId doesn't exist → no-op (idempotent)

### getNextTasks()

- Index empty → return `[]`
- Task has dependency on missing from index → skip (orphaned reference)
- Cycle in dependencies → never reach this (update() catches it)

## Limits

- No limit on number of dependencies per task
- No limit on total number of tasks

## Clarifications

### Architecture decisions

1. **Index stores both status and dependencies:** Index.json is the single source of truth. Status and dependencies are NOT stored in markdown files.

2. **Status validation:** `update()` accepts any string value for status (no enum). Validation is delegated to the CLI layer.

3. **Dependency existence:** `update()` does NOT verify that dependency IDs exist in the index (allows forward references for bootstrapping).

4. **Task removal:** `remove()` allows removal of tasks that others depend on, creating orphaned references. The CLI layer should handle warnings if needed.

5. **Missing dependencies:** `getNextTasks()` silently skips tasks that have dependencies on missing task IDs (orphaned references).

6. **No rebuild/sync methods:** This module does NOT include `rebuild()` or `hod sync` functionality. Index is only updated via `update()` and `remove()`.

### Edge case behavior

| Scenario | Behavior |
|----------|----------|
| Missing dependency ID in `getNextTasks()` | Task is skipped (not returned in ready list) |
| Empty deps array | Valid, saves `[]` |
| Empty status value | Valid, saves as-is |
| Task has dependencies on itself | `CircularDependencyError` |
| Cycle detected | `CircularDependencyError` with cycle path |
| Duplicate dependencies | Auto-deduped |
| Whitespace in dependency IDs | Auto-trimmed |

# Status
completed

# DependsOn
2

# Priority
high
