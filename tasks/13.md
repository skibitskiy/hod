# Title
Создание модуля индекса (index)

# Description
Реализовать управление индексом задач `tasks/.hod/index.json`.

Index — **едиственный источник истины** для статуса и зависимостей задач.
Markdown файлы хранят только Title, Description и custom fields.

## Функционал

### IndexService

```ts
interface TaskIndexData {
  status: string;
  dependencies: string[];
}

interface IndexData {
  [taskId: string]: TaskIndexData;
}

interface IndexService {
  load(): Promise<IndexData>;
  update(taskId: string, data: TaskIndexData): Promise<void>;
  remove(taskId: string): Promise<void>;
  getNextTasks(): Promise<string[]>;  // Возвращает ID готовых задач
}
```

### Методы

- `load()` — загрузить index.json, вернуть {} если файл не существует
- `update(taskId, data)` — обновить статус и зависимости (валидация + атомарная запись)
- `remove(taskId)` — удалить задачу из индекса (no-op если не существует)
- `getNextTasks()` — вернуть ID задач готовых к выполнению (читает index из load())

### Атомарные операции

`update()` использует atomic write-replace (POSIX):

```ts
const tempPath = `${indexPath}.tmp`;
await fs.unlink(tempPath).catch(() => {});
await fs.writeFile(tempPath, JSON.stringify(data, null, 2));
await fs.rename(tempPath, indexPath);  // atomic on POSIX
```

### Логика getNextTasks

```ts
async getNextTasks(): Promise<string[]> {
  // 1. Загрузить index
  const index = await this.load();

  // 2. Найти готовые задачи
  const ready: string[] = [];
  for (const [id, data] of Object.entries(index)) {
    // Пропущен если уже завершён
    if (data.status === 'completed') continue;

    // Проверить все зависимости
    const depsCompleted = data.dependencies.every(depId => {
      const dep = index[depId];
      return dep && dep.status === 'completed';
    });

    if (depsCompleted) {
      ready.push(id);
    }
  }

  // 3. Сортировать по ID (numeric sort)
  return sortIds(ready);
}
```

Задача готова к выполнению если:
1. Её статус `!== 'completed'`
2. Все зависимости выполнены (их статус === `'completed'`)
3. Задача существует в index

**Порядок:** sorted by ID (numeric, как `storage.list()`)

### Формат index.json

```json
{
  "1": {"status": "pending", "dependencies": []},
  "2": {"status": "completed", "dependencies": ["1"]},
  "3": {"status": "pending", "dependencies": ["1", "2"]},
  "1.1": {"status": "in_progress", "dependencies": ["1"]},
  "1.2": {"status": "pending", "dependencies": ["1", "1.1"]}
}
```

**Примечание:** Index — единственное хранилище status/deps. В markdown этих полей НЕТ.

## Обработка ошибок

```ts
class IndexLoadError extends Error {
  constructor(message: string, public cause?: Error) {
    super(message);
    this.name = 'IndexLoadError';
  }
}

class IndexWriteError extends Error {
  constructor(message: string, public cause?: Error) {
    super(message);
    this.name = 'IndexWriteError';
  }
}

class IndexCorruptionError extends Error {
  constructor(message: string, public cause?: Error) {
    super(message);
    this.name = 'IndexCorruptionError';
  }
}

class IndexValidationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'IndexValidationError';
  }
}

class CircularDependencyError extends Error {
  constructor(message: string, public cycle: string[]) {
    super(message);
    this.name = 'CircularDependencyError';
  }
}
```

### Error mapping

- `load()` с invalid JSON → `IndexCorruptionError`
- `load()` с access error → `IndexLoadError`
- `writeFile`/`rename` failures → `IndexWriteError`
- Обнаружен cycle → `CircularDependencyError`
- Invalid ID format → `IndexValidationError`

### Data loss

**Важно:** Если index.json повредился или удалён, данные о статусах и зависимостях **потеряны безвозвратно**.
Рекомендуется пользователям регулярно бэкапить `tasks/.hod/` директорию.

## Валидация

### update() проверяет:

1. **Circular dependency** — traverse graph от taskId, если найден cycle → `CircularDependencyError`
2. **Self-dependency** — taskId в своих deps → `CircularDependencyError`
3. **ID format** — regex `^\d+(\.\d+)*$` (как в Storage), max 50 chars
4. **ID length** — максимум 50 символов
5. **Duplicates** — auto-dedup зависимости
6. **Whitespace** — trim каждый dependency ID
7. **Status value** — любая строка (no enum, validation delegated to CLI)

**Примечание:** `update()` НЕ проверяет что dependency IDs существуют в индексе (bootstrap problem).

### Cycle detection algorithm

DFS с coloring (white/gray/black):
- O(V+E) complexity
- Возвращает cycle path для error message

## Интеграция

### Путь к файлу

`{tasksDir}/.hod/index.json` — hardcoded внутри tasksDir

### Создание директории

Shared helper `ensureHodDirectory()`:
- Вызывается из `update()` перед записью
- `load()` НЕ создаёт директорию
- Создаёт `.hod/` внутри `tasksDir`

### Конструктор

```ts
class IndexServiceImpl implements IndexService {
  constructor(
    private readonly tasksDir: string,
    private readonly fs: FsModule = defaultFs,
  ) {}
}
```

- Dependency injection `fs` для тестирования
- Разрешает `tasksDir` как абсолютный путь
- НЕ проверяет что `tasksDir` существует (fail-late)
- НЕ создаёт директории в конструкторе

### Экспорт из `src/index/index.ts`

- Interface `IndexService`
- Class `IndexServiceImpl`
- Factory `createIndexService(tasksDir: string, fs?: FsModule): IndexService`
- Все error classes
- Type `IndexData`
- Type `TaskIndexData`

### Shared utility

Extract `sortIds()` из Storage в `src/utils/sort.ts`:
- Numeric sort по сегментам ID
- Используется в `getNextTasks()` и Storage

### Конкурентность

**Не поддерживается в v1.** Документация: multiple CLI instances → last writer wins (atomic rename). File locking не реализуется.

## Edge cases

### load()

- Файл не существует → вернуть `{}`
- `.hod/` не существует → вернуть `{}`
- Invalid JSON → `IndexCorruptionError`
- Пустой файл (`{}`) → вернуть `{}`
- Non-object values → `IndexCorruptionError` (валидация типа)
- Task value не object → `IndexCorruptionError`

### update()

- Пустой массив deps → валидно, сохраняет `[]`
- Пустой статус → валидно, сохраняет как есть
- Дубликаты в deps → auto-dedup
- Whitespace в deps → auto-trim
- taskId не существует в индексе → добавить новую запись
- Circular dependency → `CircularDependencyError` с cycle path
- Invalid ID format → `IndexValidationError`
- ID > 50 chars → `IndexValidationError`

### remove()

- taskId не существует → no-op (idempotent)

### getNextTasks()

- Index пустой → вернуть `[]`
- Задача имеет dependency на missing из индекса → skip (orphaned reference)
- Цикл в зависимостях → никогда не дойдут до этого (update() ловит)

## Лимиты

- Нет лимита на количество dependencies у задачи
- Нет лимита на общее количество задач

# Status
completed

# DependsOn
2

# Priority
high
