# Title
Implement Subtasks Support

# Description
Extend `hod add` and `hod list` to support one-level subtasks.

## Context

- Task 5 (add) creates main tasks only: 1, 2, 3...
- Task 6 (list) should be implemented FIRST as a prerequisite
- Task 13 (Index) already handles dependencies for all task IDs
- **Maximum depth: 1 level** — only main tasks (1, 2, 3) and direct subtasks (1.1, 1.2, 2.1)
- Subtasks CANNOT have their own subtasks (no 1.1.1, 1.2.3, etc.)

## Changes to Task 5 (hod add)

### Add `--parent` flag

```bash
hod add --title "Main task"           # Creates task 1
hod add --title "Subtask" --parent 1  # Creates task 1.1
hod add --title "Another" --parent 1 # Creates task 1.2
```

**Validation:** `--parent 1.1` is INVALID (subtasks cannot have subtasks)

### CLI option registration

```ts
// src/cli/index.ts (or command registration)
program
  .command('add')
  .option('--parent <id>', 'Родительская задача (только main задачи)')
  .action(async (options) => {
    await addCommand(options, services);
  });
```

`--parent` is a **system option** (like `--dependencies`), not a config field.

### Field validation update

Update `validateFieldNames()` to exclude `parent`:

```ts
const systemFields = ['dependencies', 'parent', '_'];

function validateFieldNames(
  fields: Record<string, string>,
  config: Config,
): void {
  const availableFields = Object.values(config.fields).map(f => f.name);

  for (const fieldName of Object.keys(fields)) {
    if (systemFields.includes(fieldName)) continue;
    if (!availableFields.includes(fieldName)) {
      throw new Error(
        `Неизвестное поле '${fieldName}'. Доступные поля: ${availableFields.join(', ')}`
      );
    }
  }
}
```

### Parent validation (fail-fast)

**Execution order:**
1. Load config
2. **Validate field names** (including system options check)
3. **Validate parent** (before any data transformation)
4. Collect fields
5. Apply defaults
6. Validate required
7. Generate ID
8. ...rest of flow

```ts
// After validateFieldNames(), before collectFields()
if (options.parent) {
  // Whitespace-only → treat as empty
  const trimmed = options.parent.trim();
  if (!trimmed) {
    throw new ParentValidationError(
      "ID родительской задачи не может быть пустым или содержать только пробелы"
    );
  }

  // Format validation
  if (!/^\d+(\.\d+)*$/.test(trimmed)) {
    throw new ParentValidationError(
      `Неверный формат ID родительской задачи: '${trimmed}'`
    );
  }

  // Depth validation (only main tasks can be parents)
  if (trimmed.includes('.')) {
    throw new ParentValidationError(
      `Родительская задача '${trimmed}' является подзадачей. Подзадачи не могут иметь свои подзадачи`
    );
  }

  // Existence validation
  try {
    await storage.read(trimmed);
  } catch (error) {
    if (error instanceof StorageNotFoundError) {
      throw new ParentValidationError(
        `Родительская задача '${trimmed}' не существует`
      );
    }
    throw error;
  }
}
```

### Error class

```ts
// src/cli/errors.ts
class ParentValidationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'ParentValidationError';
  }
}
```

### ID generation functions (with collision detection)

```ts
// Generate main task ID
async function generateMainTaskId(storage: StorageService): Promise<string> {
  const tasks = await storage.list();
  const mainIds = tasks
    .map(t => t.id.split('.')[0])
    .filter((v, i, a) => a.indexOf(v) === i);

  if (mainIds.length === 0) return "1";
  const maxId = Math.max(...mainIds.map(Number));
  return String(maxId + 1);
}

// Generate subtask ID with best-effort collision detection
async function generateSubtaskId(
  parent: string,
  storage: StorageService
): Promise<string> {
  let attempt = 0;
  const maxAttempts = 100; // Safety limit

  while (attempt < maxAttempts) {
    const tasks = await storage.list();
    const parentDepth = parent.split('.').length;

    // Filter: only direct children (exactly one more segment than parent)
    const siblings = tasks.filter(t => {
      const parts = t.id.split('.');
      return parts.length === parentDepth + 1 &&
             t.id.startsWith(parent + '.');
    });

    // Extract subtask numbers
    const subNumbers = siblings
      .map(t => Number(t.id.split('.').pop()))
      .filter(n => !isNaN(n));

    // Find max, increment with attempt offset for collision handling
    const max = subNumbers.length > 0 ? Math.max(...subNumbers) : 0;
    const candidateId = `${parent}.${max + 1 + attempt}`;

    // Best-effort: check if file already exists (race condition detection)
    try {
      await storage.read(candidateId);
      // File exists, try next number
      attempt++;
      continue;
    } catch (error) {
      if (error instanceof StorageNotFoundError) {
        // File doesn't exist, safe to use
        return candidateId;
      }
      throw error;
    }
  }

  throw new Error('Не удалось сгенерировать уникальный ID после нескольких попыток');
}
```

### Dependencies validation (logical circular dependency)

**Subtasks CANNOT depend on their direct parent:**

```ts
// After parsing dependencies from --dependencies flag
if (options.parent) {
  const deps = parseDependencies(options.dependencies); // ["1", "2"]
  if (deps.includes(options.parent)) {
    throw new CircularDependencyError(
      `Подзадача не может зависеть от своей родительской задачи '${options.parent}'`,
      [options.parent, generatedId] // or just indicate the cycle
    );
  }
}
```

This is a **logical circular dependency** — parent can't complete without subtask, subtask can't complete without parent.

## Changes to Task 6 (hod list)

### Add `--tree` flag

```bash
hod list --tree
hod list --status pending --tree  # Filter + tree
hod list --tree --json             # Hierarchical JSON
```

### Tree module structure

```ts
// src/cli/tree.ts
export interface TreeNode {
  task: { id: string; title: string; status: string };
  children: TreeNode[];
}

export function buildTree(
  tasks: Array<{ id: string; task: ParsedTask }>
): TreeNode[];

export function formatTree(
  nodes: TreeNode[],
  prefix = '',
  isLast = true
): string;
```

**Export functions for unit testing.**

### Tree format (default)

```
1  pending    Main task
├──1.1  pending    Subtask 1
└──1.2  completed  Subtask 2
2  pending    Other task
```

**Long titles:** Let terminal wrap naturally (no truncation).

### Tree building algorithm (with malformed ID filtering)

```ts
function buildTree(tasks: Array<{ id: string; task: ParsedTask }>): TreeNode[] {
  // Pre-filter: validate IDs before tree building
  const validTasks = tasks.filter(({ id }) => {
    // Skip malformed IDs (data consistency issue)
    if (!/^\d+(\.\d+)*$/.test(id)) {
      console.warn(`Предупреждение: задача с невалидным ID '${id}' пропущена при построении дерева`);
      return false;
    }
    return true;
  });

  const map = new Map<string, TreeNode[]>();
  const rootTasks: TreeNode[] = [];

  for (const { id, task } of validTasks) {
    const node = { task, children: [] };

    if (!id.includes('.')) {
      rootTasks.push(node);
    } else {
      const parentId = id.substring(0, id.lastIndexOf('.'));
      if (!map.has(parentId)) map.set(parentId, []);
      map.get(parentId)!.push(node);
    }
  }

  function attachChildren(nodes: TreeNode[]): TreeNode[] {
    for (const node of nodes) {
      const children = map.get(node.task.id) || [];
      node.children = attachChildren(children);
    }
    return nodes;
  }

  return attachChildren(rootTasks);
}
```

### Orphaned subtask handling

**Orphaned subtasks show at root level WITH warning:**

```ts
// In listCommand
const orphanedTasks: string[] = [];

function detectOrphans(nodes: TreeNode[], parentExists: Set<string>): void {
  for (const node of nodes) {
    for (const child of node.children) {
      const childId = child.task.id;
      const parentId = childId.substring(0, childId.lastIndexOf('.'));

      if (!parentExists.has(parentId)) {
        orphanedTasks.push(childId);
      }
    }
  }
}

// After building tree
if (orphanedTasks.length > 0) {
  console.warn(`Предупреждение: обнаружены ${orphanedTasks.length} подзадач с отсутствующими родителями: ${orphanedTasks.join(', ')}`);
}
```

### Filtering with tree

`hod list --status pending --tree`:

1. Filter tasks first by status
2. Pre-filter malformed IDs
3. Build tree from filtered tasks
4. Detect orphaned subtasks (missing parents after filtering)
5. Show orphans at root level
6. Warn about orphans to stderr

### Tree with JSON (`--tree --json`)

**Minimal schema (id, title, status, children):**

```json
[
  {
    "id": "1",
    "title": "Main task",
    "status": "pending",
    "children": [
      { "id": "1.1", "title": "Subtask 1", "status": "pending", "children": [] },
      { "id": "1.2", "title": "Subtask 2", "status": "completed", "children": [] }
    ]
  }
]
```

- Include only `id`, `title`, `status`, `children`
- Custom fields NOT included in tree JSON (minimal schema)
- Always includes `children` array (empty if no subtasks)

### Flat list remains default

```bash
hod list  # Still shows flat list
```

## Integration

### Extended AddCommandOptions

```ts
export interface AddCommandOptions {
  [fieldName: string]: string | undefined;
  dependencies?: string;
  parent?: string;  // NEW: parent task ID (main tasks only)
}
```

### Extended ListCommandOptions

```ts
export interface ListCommandOptions {
  [fieldName: string]: string | undefined;
  json?: boolean;
  tree?: boolean;  // NEW: tree view
}
```

### Dependencies validation rules

Subtasks can have their own dependencies:

```bash
hod add --title "Subtask" --parent 1 --dependencies 2,3
```

**Rules:**
- Subtask CANNOT depend on its direct parent (logical circular dep)
- Subtask CAN depend on siblings, other tasks, etc.
- Validated by Index.update() for circular dependencies
- No restriction on dependency levels

## Edge Cases

### ID generation

| Scenario | Behavior |
|----------|----------|
| Parent not found | Error (fail-fast) |
| Parent is subtask (1.1) | Error: depth limit |
| Parent has many subtasks | Find max correctly |
| Gaps [1.1, 1.5] | Creates 1.6 |
| Empty parent string | Error: "cannot be empty or whitespace-only" |
| Whitespace parent "   " | Error: "cannot be empty or whitespace-only" |
| Race condition (duplicate ID) | Best-effort: retry with +1 |

### Tree display

| Scenario | Behavior |
|----------|----------|
| Orphaned subtask (parent deleted) | Show at root + warning to stderr |
| Orphaned by filtering (parent filtered out) | Show at root + warning to stderr |
| Long task names | Terminal wraps naturally (no truncation) |
| Malformed ID (1., 1..2) | Pre-filtered + warning |
| Unicode characters | Handle in tree drawing |

### Validation

| Scenario | Behavior |
|----------|----------|
| Subtask depends on parent | Error: logical circular dep |
| `--parent 999` (doesn't exist) | Error |
| `--parent ""` (empty) | Error |
| `--parent "   "` (whitespace) | Error |
| `--parent 1.1` (subtask) | Error: depth limit |
| `--parent` in field validation | Excluded as system field |

### Combining flags

| Command | Output |
|---------|--------|
| `hod list --tree --json` | Hierarchical JSON (minimal schema) |
| `hod list --status pending --tree` | Filtered tree + orphans warning |
| `hod list --json` | Flat JSON (full fields) |

## Testing

### Unit Tests

**Tree module (`src/cli/tree.ts`):**
- `buildTree()` — flat list, nested, orphaned, malformed IDs
- `formatTree()` — connectors, indentation, long titles

**ID generation:**
- `generateMainTaskId()` — empty, existing, gaps
- `generateSubtaskId(parent)` — empty parent, existing, gaps
- Collision detection — simulate existing file

**Parent validation:**
- Exists, invalid format, is subtask, empty, whitespace-only

### Integration Tests

- Create subtask under main task
- Create multiple subtasks under same parent
- Error: subtask as parent
- Error: non-existent parent
- Error: empty/whitespace parent
- Error: subtask depends on parent
- Tree view output (single level)
- Tree with filtering (orphans + warning)
- Tree with JSON (minimal schema)
- Malformed IDs filtered with warning
- Dependencies with subtasks

## Implementation Prerequisites

1. **Task 6 (list command) must be implemented first**
2. Tree logic in separate module: `src/cli/tree.ts`
3. New error class: `ParentValidationError`

## DependsOn
5, 6

# Priority
high
