# Title
Create CLI commands `hod update`, `hod delete` and `hod move`

# Description
Implement commands for modifying, deleting and moving tasks.

## Command `hod update`

Updates fields of an existing task. Accepts task ID as a positional argument and a set of options to modify fields.

### Arguments

- `<id>` — ID of the task to update (required positional argument)
- `--field-name "value"` — options to update fields from configuration (dynamic)
- `--dependencies "ids"` — comma-separated dependencies

### Logic

1. Validate ID format using regex from validation module
2. Check task existence via `storage.exists()` — throw `StorageNotFoundError` if not found
3. Read current content via `storage.read()`
4. Parse via `parser.parse()` to get current `ParsedTask`
5. Validate field names from options (fail-fast, like in `list.ts`)
6. Collect new field values from options (reuse `collectFields` from `add.ts`)
7. Parse dependencies from `--dependencies` option (reuse `parseDependencies` from `add.ts`)
8. Build updated `ParsedTask`: start with current task, replace values for any fields that were provided in options
9. Serialize via `parser.serialize()`
10. Write via `storage.update()` (atomic)
11. Update index via `index.update()` (rollback storage if this fails)
12. Output success message

### Field update rules

- Specified fields replace current values
- Unspecified fields remain unchanged (no merging — keep original value)
- Empty string for optional field (e.g., `--description ""`) removes that field from markdown
  - Description can be removed (it's optional) — set to `undefined` before serialization
  - Status and Dependencies are always included by parser — cannot be removed
  - Empty string for Status (`--status ""`) — error, required field cannot be empty
  - Custom fields can be removed
- Empty string for required field (e.g., `--title ""`) — throws validation error before serialization
- When `--dependencies` is provided — full array replacement (not merged with existing)
- When `--dependencies` is NOT provided — keep existing dependencies unchanged
- Empty string for dependencies (`--dependencies ""`) — clears all dependencies (sets to empty array)
- All field values are trimmed (consistent with `add.ts` collectFields)

### Required field validation

- Validate the final ParsedTask after applying updates
- If required field exists in current task and is not provided in update — validation passes
- Example: Task has Title "Old". User runs `hod update 1 --description "New"` — succeeds (title exists in result)

### Dependency validation

- Do NOT validate that dependency IDs exist in storage
- Orphaned references are acceptable in v1 (consistent with delete behavior)
- `index.update()` validates ID format but not existence

### Error handling

- Invalid ID → Error with format description (separate validation for better UX)
- Non-existent ID → `StorageNotFoundError` with message "Задача {id} не существует"
- Unknown field → Error with list of available fields
- Empty required field → Validation error "Поле '{field}' не может быть пустым"
- Circular dependency → `CircularDependencyError` from index
- Storage write error → fatal error
- Index update failure → rollback storage by updating with old content, then throw error
  - If rollback fails, log warning and throw original error (same pattern as `add.ts`)

---

## Command `hod delete`

Deletes a task by ID.

### Arguments

- `<id>` — ID of the task to delete (required positional argument)
- `-r, --recursive` — flag for deleting task with all its subtasks

Note: In this system, subtasks cannot have subtasks. Only direct children exist, so "recursive" means deleting all direct children of the task.

### Logic

1. Validate ID format
2. Check task existence via `storage.exists()` — error if not found
3. Check for subtasks via `storage.list()` — find all direct child tasks using depth-based matching:
   - A task is a subtask if: `parts.length === parentParts.length + 1 && id.startsWith(parentId + '.')`
   - Example: Task `1.1` is a child of `1`, but task `1.10` is NOT a child of `1.1`
4. If subtasks exist and `-r` flag is not specified:
   - Output error message about existing subtasks
   - Output list of subtasks
   - Exit with code 1
5. If subtasks exist and `-r` flag is specified:
   - Collect all direct subtasks (depth-based matching: only tasks with `parts.length === parentDepth + 1`)
   - Delete each subtask from storage first, then from index
6. Delete the task itself via `storage.delete()`
7. Remove task from index via `index.remove()`
8. Output success message

### Behavior with subtasks

- Without `-r` flag: throw error with list of subtasks (consistent with other commands, testable)
  - Message: "Задача {id} имеет подзадачи: {list}. Используйте -r для рекурсивного удаления"
- With `-r` flag: delete task and all its direct subtasks
- Note: Subtasks cannot have subtasks in this system (only one level of nesting)

### Subtask detection

Use depth-based matching to find direct children only:
```typescript
function findDirectSubtasks(parentId: string, allTasks: Task[]): Task[] {
  const parentDepth = parentId.split('.').length;
  return allTasks.filter(task => {
    const parts = task.id.split('.');
    return parts.length === parentDepth + 1 && task.id.startsWith(parentId + '.');
  });
}
```

### Handling orphaned dependencies

- If other tasks depend on the deleted one, leave as is
- Orphaned references are acceptable in v1
- Command `hod sync` (future) will be able to clean up such references

---

## Command `hod move`

Moves a task under a new parent. Creates a new task with the same fields under the new parent and deletes the old one.

**Note:** This command is NOT for renaming tasks (changing IDs). It only changes the parent relationship.

### Arguments

- `<id>` — ID of the task to move (required positional argument)
- `--parent <id>` — ID of the new parent (REQUIRED)
  - Must be a main task (not a subtask)
  - Cannot be the same as the current parent (no-op detection)

### Logic

1. Validate format of the task being moved
2. Validate format of the new parent
3. Check existence of the task being moved
4. Check existence of the new parent
5. Verify that the new parent is a main task (not a subtask)
6. Check if new parent equals current parent:
   - Extract current parent from task ID (if any)
   - If same as new parent — no-op, output success message and exit
7. Check for subtasks on the task being moved:
   - If there are subtasks — error, move is prohibited
8. Read and parse the current task
9. Generate new ID under the new parent
10. Check dependencies for cycles considering the new ID
11. Create new task with new ID via `storage.create()`
12. Update index via `index.update()` (with rollback on error)
13. Delete old task via `storage.delete()`
14. Remove old task from index via `index.remove()`
15. Output success message with new ID

### Limitations

- Cannot move a task if it has subtasks
  - Message: "Задача {id} имеет подзадачи. Перемещение задач с подзадачами не поддерживается"
- Cannot make a subtask a parent (only main tasks can be parents)
  - Message: "Задача {parent} является подзадачей. Только основные задачи могут быть родительскими"
- Self-move detection: if new parent equals current parent, operation is a no-op (success message)
- Dependencies are preserved without changes — other tasks that reference the moved task will have orphaned references
  - Note: We do NOT scan other tasks to update their dependencies (too expensive for v1)
- All task fields are copied without changes

### Error handling

- If creating new task fails — rollback (don't delete old task)
- If updating index fails — rollback (delete new task from storage)
- If rollback fails — log warning and throw original error (same pattern as `add.ts`)

### Operation order

To minimize inconsistency window:
1. Create new task in storage
2. Update index with new ID (rollback: delete new task)
3. Delete old task from storage
4. Remove old ID from index

If step 3 fails, we have duplicate tasks but both are indexed (recoverable via manual cleanup or `hod sync`).

### ID generation

- Use `generateSubtaskId()` from `add.ts` — no additional index check needed
- The function already has collision detection with 100 retries
- Index is derived from storage, so if ID doesn't exist in storage, it won't exist in index
- Note: If another task has a dependency reference to the generated ID, it becomes an orphaned reference (acceptable in v1)
  - Example: Task `2` has dependencies `["3.1"]`. User moves task `1` under `3`. New ID is `3.1`. Task `2`'s reference now points to the moved task (acceptable)

---

## General requirements

### File structure

```
src/cli/commands/
├── update.ts           # update command implementation
├── delete.ts           # delete command implementation
├── move.ts             # move command implementation
├── update.test.ts      # tests
├── delete.test.ts      # tests
└── move.test.ts        # tests
```

### Command registration

Add `registerUpdateCommand()`, `registerDeleteCommand()` and `registerMoveCommand()` functions to `src/cli/index.ts` by analogy with existing `registerAddCommand()` and `registerListCommand()`.

Use `registerConfigOptions()` for dynamic options from configuration.

### Code reuse

From `add.ts` can be reused:
- `collectFields` — collect field values from options
- `validateFieldNames` — validate field names
- `validateParent` — validate parent task
- `parseDependencies` — parse dependencies from string
- `fieldsToParsedTask` — convert fields to ParsedTask
- `generateMainTaskId` — generate main task ID
- `generateSubtaskId` — generate subtask ID

### Error messages

All messages in Russian. Use these templates:

| Scenario | Message |
|----------|---------|
| Invalid ID format | `Невалидный формат ID: '{id}'` |
| Task not found (update/delete/move) | `Задача {id} не существует` |
| Unknown field | `Неизвестное поле '{field}'. Доступные поля: {available}` |
| Empty required field | `Поле '{field}' не может быть пустым` |
| Has subtasks (delete without -r) | `Задача {id} имеет подзадачи: {list}. Используйте -r для рекурсивного удаления` |
| Has subtasks (move) | `Задача {id} имеет подзадачи. Перемещение задач с подзадачами не поддерживается` |
| Parent not found (move) | `Родительская задача {parent} не существует` |
| Parent is subtask (move) | `Задача {parent} является подзадачей. Только основные задачи могут быть родительскими` |
| Update success | `✓ Задача {id} обновлена` |
| Delete success | `✓ Задача {id} удалена` |
| Move success | `✓ Задача {old_id} перемещена в {new_id}` |
| Move success (same parent) | `✓ Задача {id} уже находится под родителем {parent}` |
| Move parent not specified | `--parent обязателен для команды move` |
| Empty status field | `Поле 'Status' не может быть пустым` |

### Testing

Integration-First approach with memfs for mocking filesystem. All services are real instances.

Test cases for update:
- Update single field
- Update multiple fields simultaneously
- Update dependencies with cycle check
- Update with non-existent dependency ID (orphaned reference allowed)
- Set required field to empty string — validation error
- Set Status to empty string — error, required field cannot be empty
- Set `--dependencies ""` — clears all dependencies
- Update without providing required field — succeeds if field exists in task
- Values are trimmed (leading/trailing whitespace removed)
- Invalid/non-existent ID
- Unknown field

Test cases for delete:
- Delete existing task without subtasks
- Attempt to delete with subtasks without `-r` — error with list
- Delete with subtasks with `-r` flag — deletes task and all direct children
- Delete with `-r` when no subtasks exist — silent success
- Subtask detection: `1.10` is NOT a subtask of `1.1` (depth-based matching)
- Invalid/non-existent ID

Test cases for move:
- Move subtask to different parent (1.1 -> 2)
- Move main task under another main task (1 -> 2, becomes 2.1)
- Attempt to move with subtasks — error with message
- Move task to non-existent parent — error with message
- Move without --parent — error with message
- Subtask as new parent — error with message
- Self-move (same parent) — no-op with success message
- Move creates orphaned references (other tasks still reference old ID)
- ID collision scenario (another task references generated new ID) — acceptable
- Rollback on new task creation error
- Rollback failure — warning logged, original error thrown

---

## Implementation Clarifications

### Error handling pattern

All commands follow the same error handling pattern:
- Throw exceptions (never call `process.exit()` directly in command code)
- CLI wrapper in `index.ts` catches exceptions and calls `process.exit(1)`
- All error scenarios use exit code 1
- This makes commands testable and consistent with existing patterns

### Value normalization

- All field values are trimmed (consistent with `add.ts` `collectFields`)
- Empty string after trim is treated as empty value
- Whitespace-only strings become empty strings after trim

### Concurrent operations

- v1 does not handle concurrent access
- If another process creates/deletes tasks during an operation, behavior is undefined
- Documented as v1 limitation (single-user CLI tool)

### Subtask detection algorithm

Subtasks cannot have subtasks in this system (only one level of nesting). Use depth-based matching to find direct children only:

```typescript
function findDirectSubtasks(parentId: string, allTasks: Task[]): Task[] {
  const parentDepth = parentId.split('.').length;
  return allTasks.filter(task => {
    const parts = task.id.split('.');
    return parts.length === parentDepth + 1 && task.id.startsWith(parentId + '.');
  });
}
```

This ensures:
- `1.1` is a child of `1` ✓
- `1.10` is NOT a child of `1.1` ✓
- No nested subtasks exist (no `1.1.1`)

### Index update order for delete

For delete with `-r`:
- Delete each direct subtask individually from both storage and index
- Order: storage first, then index (for each subtask)
- No special sorting needed (all subtasks are at same depth)
- Do NOT batch index updates or use `index.rebuild()`

### Cycle detection timing

For update command:
- Write to storage FIRST
- Then update index (which checks for cycles)
- If index update fails, rollback storage delete
- No need to add `index.validateCycle()` method

### Error types to use

- Invalid ID format → generic `Error` with message "Невалидный формат ID: '{id}'"
- Parent validation (move) → `ParentValidationError` from add.ts
- Other errors → reuse existing error classes where possible

### Current parent extraction

To extract current parent from task ID:
```typescript
function extractCurrentParent(taskId: string): string | undefined {
  if (!taskId.includes('.')) return undefined; // Main task, no parent
  return taskId.split('.')[0]; // First segment is parent
}
```

Examples:
- `1` → `undefined` (main task)
- `1.1` → `1`
- `1.2` → `1`

### Rollback mechanism

When index update fails during update command:
- Use `storage.update(id, originalContent)` with the markdown content read in step 3
- If rollback fails, log warning and throw original error

### Subtask list format

When displaying subtasks in error message:
- Use comma-separated format: `1.1, 1.2, 1.3`
- Example: "Задача 1 имеет подзадачи: 1.1, 1.2. Используйте -r для рекурсивного удаления"

---

## DependsOn
task-6, task-13

# Priority
medium
