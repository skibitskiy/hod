# Title
Создание CLI команды `hod list`

# Description
Реализовать команду вывода списка задач с фильтрацией и форматированием.

## Usage

```bash
hod list
hod list --status pending
hod list --status completed --json
hod list --json
```

## Prerequisite Changes

**Изменения в Parser** (task 4) — lowercase для custom полей:

В `src/parser/parser.ts` изменить `buildTask()`:

```ts
// Было (строки 126-129):
for (const [key, value] of sections.entries()) {
  if (!standardKeys.has(key)) {
    task[key] = value;  // Сохраняет оригинальный ключ (Priority, Assignee)
  }
}

// Стало:
for (const [key, value] of sections.entries()) {
  if (!standardKeys.has(key)) {
    const lowerKey = key.toLowerCase();  // Priority -> priority
    task[lowerKey] = value;
  }
}
```

**Следствие:** `serialize()` будет писать lowercase заголовки для custom полей:
```markdown
# priority
high
```

**Backwards compatibility:** После `hod update` файлы перезапишутся с lowercase заголовками. Парсинг будет работать с обоими вариантами.

---

## Requirements

### CLI Framework

- **commander.js** для парсинга аргументов
- Использовать `.allowUnknownOption(true)` для поддержки динамических полей
- Использовать `createServices()` factory из `src/cli/services.ts`

### Аргументы

Динамические фильтры из `config.fields`:
- `--field-name value` — фильтр по equality
- Пример: `--status pending`, `--priority high`
- Значения всегда **string** (commander по умолчанию)

**Специальные аргументы:**
- `--json` — вывод в JSON формате (вместо таблицы)
- `--json` комбинируется с фильтрами: `hod list --status pending --json`

### Доступ к Config

```ts
// Использовать load() для получения Config объекта:
const config = await services.config.load();
const fields = config.fields;

// Доступ к CLI именам для валидации:
const availableFields = Object.values(fields).map(f => f.name);  // ['title', 'status', ...]
```

### Валидация полей (Fail-Fast)

**Валидировать поля ДО загрузки задач:**

```ts
// После загрузки config, ДО storage.list()
const config = await services.config.load();
const fields = config.fields;
const availableFields = Object.values(fields).map(f => f.name);

for (const [key, value] of Object.entries(filters)) {
  if (key === 'json') continue;
  if (!availableFields.includes(key)) {
    throw new Error(
      `Неизвестное поле '${key}'. Доступные поля: ${availableFields.join(', ')}`
    );
  }
}
```

- `dependencies` **НЕ является фильтруемым полем** → ошибка если указан
- Fail-fast перед дорогостоящими операциями

### Логика фильтрации

```ts
// 1. Загрузить все задачи из Storage
const tasks = await storage.list();

// 2. Распарсить каждую задачу с обработкой ошибок
const parsed: Array<{ id: string; task: ParsedTask }> = [];
for (const task of tasks) {
  try {
    parsed.push({ id: task.id, task: parser.parse(task.content) });
  } catch (error) {
    // Включить детали ошибки
    console.error(`Предупреждение: задача ${task.id}: ${error.message} — пропущена`);
  }
}

// 3. Применить фильтры из CLI аргументов
const filtered = parsed.filter(({ id, task }) => {
  for (const [key, value] of Object.entries(filters)) {
    if (key === 'json') continue;
    // Поле отсутствует → задача не проходит фильтр
    if (task[key] === undefined) return false;
    // Строгое равенство (case-sensitive)
    if (task[key] !== value) return false;
  }
  return true;
});
```

**Правила фильтрации:**
- Фильтр применяется к **parsed task**
- **Case-sensitive**: `--status Pending` ≠ `status: "pending"`
- **Строгое равенство**: тип и значение должны совпадать
- **AND логика**: все фильтры должны выполниться
- Поле отсутствует у задачи → `false` (задача не проходит)

**Работает с lowercase полями:**
```ts
// После изменений в парсере:
task.title      // lowercase ✓
task.status     // lowercase ✓
task.priority   // lowercase ✓ (было task['Priority'])
task.assignee   // lowercase ✓ (было task['Assignee'])

// Фильтрация работает напрямую:
task[cliName] === filterValue  // task['priority'] === 'high' ✓
```

### Вывод в таблицу

Формат для stdout (по умолчанию):
```
ID  Status     Title
1   pending    Название задачи
2   -          Задача без статуса
3   completed  Другая задача
```

**Расчёт ширины колонок:**

```ts
// 1. Собрать все поля из config (сортировка по Markdown ключу, alphabetically)
const fieldKeys = Object.keys(fields).sort();  // ['Description', 'Status', 'Title']

// 2. Рассчитать максимальную ширину для каждой колонки
const colWidths: Record<string, number> = { id: 4 };
for (const key of fieldKeys) {
  const cliName = fields[key].name;
  const header = key;  // Markdown key как заголовок
  const maxVal = Math.max(
    header.length,
    ...filtered.map(f => (f.task[cliName] ?? '-').toString().length)
  );
  colWidths[cliName] = maxVal;
}

// 3. Вывести заголовок
const header = `ID  ${fieldKeys.map(k => {
  const cliName = fields[k].name;
  return k.padEnd(colWidths[cliName]);
}).join('  ')}`;
console.log(header);

// 4. Вывести данные
for (const { id, task } of filtered) {
  const values = fieldKeys.map(k => {
    const cliName = fields[k].name;
    const val = task[cliName];
    // Обработка спецсимволов и пустых значений
    const isEmpty = val === undefined || val === '';
    const clean = isEmpty
      ? '-'
      : val.toString().replace(/[\n\r\t]+/g, ' ');
    return clean.padEnd(colWidths[cliName]);
  });
  console.log(`${id.padEnd(4)}${values.join('  ')}`);
}
```

**Правила таблицы:**
- **Разделитель**: 2 пробела между колонками
- **ID колонка**: фиксированная ширина 4 символа, левая
- **Заголовки**: Markdown ключи как-is (Title, Status, Description)
- **Сортировка колонок**: по Markdown ключу alphabetically
- **Ширина**: максимальная длина значения во всех задачах (no truncation)
- **Unicode**: использовать `string.length` (приемлемо для v1)
- **Спецсимволы**: заменить `\n\r\t` на пробел
- **Пустые значения**: показать `-` (undefined или empty string)
- **Подзадачи** (1.1, 1.2): включаются в общий список
- **Duplicates**: допустимы (выводить как есть)

**Пустой результат:**
```
Нет задач
```

### Вывод в JSON

Формат при `--json`:
```json
[
  {
    "id": "1",
    "title": "Название",
    "description": "Описание",
    "status": "pending",
    "dependencies": ["1", "2"]
  },
  {
    "id": "2",
    "title": "Другая",
    "status": "completed",
    "dependencies": []
  }
]
```

**Правила JSON:**
- Все поля из config + `id` + `dependencies`
- `dependencies` из **parsed task content** (НЕ из index)
- `dependencies` сортировать с `sortIds()` для предсказуемости
- Custom fields всегда `string` (parser гарантирует)
- Пропускать missing fields (не добавлять в JSON)
- Empty string → включать как `""`
- Пустой результат → `[]`
- Спецсимволы экранируются автоматически `JSON.stringify`
- Сохранить оригинальное содержимое (включая newlines)

```ts
// Подготовка данных для JSON
const result = filtered.map(({ id, task }) => {
  const obj: Record<string, string | string[]> = { id };

  for (const [mdKey, field] of Object.entries(fields)) {
    const val = task[field.name];
    // Пропустить missing fields (undefined)
    if (val !== undefined) {
      obj[field.name] = val;
    }
  }

  // Dependencies из парсера
  obj.dependencies = sortIds(task.dependencies);
  return obj;
});

console.log(JSON.stringify(result, null, 2));
```

**Пустой результат для JSON:**
```json
[]
```

### Обработка ошибок

Все ошибки используют **русские сообщения**:

```ts
// Unknown field (fail-fast)
throw new Error(
  `Неизвестное поле '${fieldName}'. Доступные поля: ${availableFields.join(', ')}`
);

// Parse errors (пропустить задачу, продолжить)
console.error(`Предупреждение: задача ${task.id}: ${error.message} — пропущена`);

// Storage read errors (graceful degradation)
// storage.list() уже ловит ошибки чтения отдельных файлов молча
// Дополнительные warning не нужны для v1

// Storage access errors (пробрасывать, fatal)
if (error instanceof StorageAccessError) {
  console.error(error.message);
  process.exit(1);
}
```

**Exit codes:**
- **0**: Success (включая пустой результат, warnings в stderr)
- **1**: Error (фатальная ошибка в stderr)

### Service Factory

**Обновить `src/cli/services.ts`** — добавить `parser` в интерфейс и фабрику:

```ts
// src/cli/services.ts
export interface Services {
  config: ConfigService;
  storage: StorageService;
  parser: ParserService;  // ← добавить
  index: IndexService;
}

export async function createServices(configPath?: string): Promise<Services> {
  const config = new ConfigServiceImpl(configPath);
  const tasksDir = await config.getTasksDir();

  return {
    config,
    storage: new StorageServiceImpl(tasksDir),
    parser: new ParserServiceImpl(),  // ← добавить
    index: new IndexServiceImpl(tasksDir),
  };
}
```

**Также обновить `src/cli/commands/add.ts`** — использовать `services.parser` вместо прямого импорта:

```ts
// Было:
import { ParserService } from '../../parser/parser.js';
const parsed = ParserService.parse(markdown);

// Стало:
const parsed = services.parser.parse(markdown);
```

## Code Structure

```
src/cli/
├── commands/
│   ├── add.ts           # Task 5 implementation
│   ├── list.ts          # Task 6 implementation
│   ├── add.test.ts
│   └── list.test.ts
├── services.ts          # createServices() factory
└── index.ts             # Main CLI entry point (future task)
```

### Export Format

```ts
export interface ListCommandOptions {
  [fieldName: string]: string | undefined;  // Dynamic filters from config
  json?: boolean;  // Special flag
}

export async function listCommand(
  options: ListCommandOptions,
  services: Services,
): Promise<void> {
  // Implementation
}
```

## Testing

**Подход: Integration-First с mocked FS layer**

Мокать только файловую систему через **memfs**. Все сервисы (Config, Storage, Parser, Index) — реальные инстансы.

**Захват stdout/stderr:** мокать `console.log` и `console.error`:

```ts
// list.test.ts
import { fs } from 'memfs';
import { createServices } from '../services.js';
import { listCommand } from './list.js';
import { vi } from 'vitest';

describe('listCommand', () => {
  let logs: string[] = [];
  let errors: string[] = [];

  beforeEach(async () => {
    logs = [];
    errors = [];
    vi.spyOn(console, 'log').mockImplementation((msg) => logs.push(String(msg)));
    vi.spyOn(console, 'error').mockImplementation((msg) => errors.push(String(msg)));

    // Настройка memfs с тестовыми файлами
    fs.mkdirSync('/tasks', { recursive: true });
    fs.writeFileSync('/tasks/1.md', '# Title\nЗадача 1\n# Status\npending');
    fs.writeFileSync('/tasks/2.md', '# Title\nЗадача 2\n# Status\ncompleted');
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('фильтрует задачи по статусу', async () => {
    const services = await createServices('/hod.config.yml');
    await listCommand({ status: 'pending' }, services);
    expect(logs.some(l => l.includes('Задача 1'))).toBe(true);
    expect(logs.some(l => l.includes('Задача 2'))).toBe(false);
  });
});
```

**Тест-кейсы:**
- Фильтрация по одному полю (`--status pending`)
- Фильтрация по нескольким полям (AND логика)
- Case-sensitive фильтрация (`Pending` ≠ `pending`)
- Пустой результат → "Нет задач" / `[]`
- JSON формат вывода (валидность JSON, сортировка dependencies)
- Табличный формат (колонки, выравнивание, заголовки)
- Неизвестное поле → ошибка с списком доступных (fail-fast)
- Dependencies поле → ошибка (не фильтруемое)
- Задача с ошибкой парсинга → warning с деталями, пропущена
- Пустые/undefined значения → "-" в таблице, пропущены в JSON
- Newlines/tabs в значениях → заменены на пробел в таблице
- Custom поля из config (lowercase keys в ParsedTask)
- Подзадачи (1.1, 2.5) — включаются в общий список

## Implementation Notes

### Commander.js Integration

```ts
// src/cli/index.ts (future)
import { Command } from 'commander';
import { listCommand } from './commands/list.js';
import { createServices } from './services.js';

const program = new Command();

program
  .command('list')
  .description('Вывести список задач')
  .allowUnknownOption(true)  // Для динамических полей
  .option('--json', 'Вывод в JSON формате')
  .action(async (options, command) => {
    const services = await createServices();
    // Парсим неизвестные опции вручную
    const filters = parseUnknownOptions(command.opts());
    await listCommand({ ...filters, json: options.json }, services);
  });
```

### Dependencies Sorting

Использовать `sortIds()` из `src/index/index.ts`:

```ts
import { sortIds } from '../../index/index.js';

obj.dependencies = sortIds(task.dependencies);
```

### Unicode Width

Для v1: использовать `string.length` — приемлемо для большинства случаев.
Для v2: рассмотреть `cli-width` библиотеку для точного расчёта ширины Unicode символов.

## Edge Cases

### Фильтрация

| Сценарий | Поведение |
|----------|-----------|
| Пустые фильтры | Показать все задачи |
| Фильтр по несуществующему значению | Пустой результат (exit 0) |
| Поле отсутствует у задачи (undefined) | Задача не проходит фильтр |
| Поле есть но empty string | Задача не проходит фильтр (!== value) |
| `--dependencies 1` | Ошибка: не фильтруемое поле |
| `--status Pending` vs `pending` | Не совпадают (case-sensitive) |
| Несколько фильтров | AND логика |
| Custom поле `priority` | Работает: `task.priority === filterValue` |

### Парсинг

| Сценарий | Поведение |
|----------|-----------|
| Задача с невалидным markdown | Warning в stderr с деталями, пропустить |
| Пустой файл | Warning, пропустить |
| Нет Title секции | ParseError, warning, пропустить |
| Частично валидная задача | Warning, пропустить (недостаточно для list) |
| Custom поле `# Priority` → `task.priority` | lowercase маппинг (после изменений) |

### Вывод

| Сценарий | Поведение |
|----------|-----------|
| Длинные значения | No truncation, расширить колонку |
| Newlines в Description | Заменить на пробел (таблица) / сохранить (JSON) |
| Tab символы | Заменить на пробел (таблица) / сохранить (JSON) |
| Пустое поле (`undefined`) | Показать `-` (таблица) / пропущен (JSON) |
| Empty string (`""`) | Показать `-` (таблица) / `""` (JSON) |
| Unicode emoji | `string.length` (может не идеально выравниваться) |
| Пустой результат | "Нет задач" (таблица) / `[]` (JSON) |
| Нет задач в storage | "Нет задач" (таблица) / `[]` (JSON) |
| Дубликаты ID | Выводить как есть (все строки) |

### Errors

| Сценарий | Поведение |
|----------|-----------|
| Неизвестное поле | Exit 1, сообщение с доступными полями |
| StorageAccessError | Exit 1, пробросить ошибку |
| Файл не читается | Silent (storage.list() обрабатывает) |
| ParseError | Warning с деталями, пропустить задачу |
| Пустой результат | Exit 0 (не ошибка) |

## DependsOn
4, 13

# Priority
medium
