# Title
Create CLI command `hod add`

# Description
Implement the command for adding tasks.

## Usage

```bash
hod add --title "Task name" --description "Task description" --status pending
hod add --title "Task" --priority high --dependencies 1,2,3
hod add --title "Quick task"  # minimal required field
```

## Requirements

### CLI Framework

- **commander.js** for argument parsing
- Dynamically generate flags from config
- Map `--field-name` (kebab-case) to markdown field via `config.fields[key].name`

Example mapping:
- `--title` → `fields.Title.name = "title"` → `# Title`
- `--my-custom-field` → `fields.MyCustomField.name = "my-custom-field"` → `# MyCustomField`

### Argument Parsing

- Read config from `hod.config.yml` for field definitions
- Parse CLI arguments (`--field-name value`)
- Multi-word values: standard shell quoting (user provides quotes)
- **Error on unknown fields** — prevent typos
- Trim whitespace from all values
- Empty strings (after trim) treated as missing

### System Fields

`--dependencies` is a special field (not in config):
- Format: comma-separated `--dependencies 1,2,3`
- Parsed to string array: `["1", "2", "3"]`
- No validation that dependency IDs exist (allow forward references)
- Circular dependency check: handled by Index.update()

### No Prompting

**No interactive prompting.** Fail fast with clear error messages.

Example: `Missing required field 'Title'. Use --title "Task name"`

### ID Generation

**User never provides ID.** Always auto-generated.

Algorithm:
```ts
// 1. Get list from storage
const tasks = await storage.list();

// 2. Extract main task IDs (filter out subtasks)
const mainIds = tasks
  .map(t => t.id.split('.')[0])  // "1.5" → "1"
  .filter((v, i, a) => a.indexOf(v) === i);  // unique

// 3. Find max, increment
if (mainIds.length === 0) return "1";
const maxId = Math.max(...mainIds.map(Number));
return String(maxId + 1);
```

Result: always generates main task IDs (1, 2, 3, 4, ...)

### Task Creation Workflow

```ts
// 1. Collect field values from arguments
const fields = collectFields(args, config);

// 2. Apply defaults from config
const withDefaults = applyDefaults(fields, config);

// 3. Validate required fields
validateRequired(withDefaults, config);

// 4. Generate ID
const id = generateId(storage);

// 5. Serialize to Markdown
const markdown = parser.serialize(withDefaults);

// 6. Create in Storage
await storage.create(id, markdown);

// 7. Update Index (with rollback)
try {
  await index.update(id, fields.dependencies || []);
} catch (error) {
  await storage.delete(id);  // Rollback
  throw error;
}
```

### Field Validation

- **Required fields:** check after defaults applied
- **Custom fields:** no validation (any string accepted)
- **Status field:** no enum (any string accepted)
- **Dependencies:** circular dependency checked by Index

### Error Handling

All errors use **Russian messages**, user-friendly, actionable.

```ts
// Missing required field
"Не указано обязательное поле 'Title'. Используйте --title \"Название задачи\""

// Unknown field (list ALL available fields from config)
const availableFields = Object.values(config.fields).map(f => f.name).join(', ');
"Неизвестное поле '{fieldName}'. Доступные поля: {availableFields}"

// Storage errors (propagate)
StorageAlreadyExistsError, StorageWriteError, etc.

// Index errors (with rollback)
CircularDependencyError → rollback storage, then throw

// Config errors (fatal)
ConfigLoadError, ConfigValidationError → exit 1
```

### Field Name Mapping

CLI arg name must **exactly match** `config.fields[key].name`:

```ts
// Config: { Title: { name: 'title' }, Priority: { name: 'priority' } }
// Valid: --title, --priority
// Invalid: --Title, --TITLE, --titel
```

Config already enforces kebab-case for `name` fields, so lookup is exact match.

### Transaction/Rollback

If Storage succeeds but Index fails:
1. Attempt `storage.delete(id)` to rollback
2. If rollback fails → log warning, throw original error
3. User may need manual cleanup or `hod sync`

### Success Output

Simple format to stdout:
```
✓ Задача создана: 1
```

No verbose/detailed output in v1. Consistent across all CLI commands.

### Integration

Uses four modules:
- **Config:** field definitions, defaults, CLI arg mapping
- **Storage:** file creation with atomic write
- **Parser:** Markdown serialization
- **Index:** dependency updates

## Code Structure

```
src/cli/
├── commands/
│   ├── add.ts           # Task 5 implementation
│   └── add.test.ts      # Tests
├── services.ts          # createServices() factory
└── index.ts             # Main CLI entry point (future task)
```

### Service Factory

```ts
// src/cli/services.ts
export interface Services {
  config: ConfigService;
  storage: StorageService;
  parser: ParserService;
  index: IndexService;
}

export async function createServices(configPath?: string): Promise<Services> {
  // 1. Load config first (needed for tasksDir)
  const configService = createConfigService();
  const config = await configService.load(configPath);

  // 2. Create services with tasksDir from config
  const storageService = createStorageService(config.tasksDir);
  const parserService = createParserService();
  const indexService = createIndexService(config.tasksDir);

  return { config: configService, storage: storageService, parser: parserService, index: indexService };
}
```

### Export Format

```ts
export interface AddCommandOptions {
  [fieldName: string]: string | undefined;  // Dynamic fields from config
  dependencies?: string;  // Special field
}

export async function addCommand(
  options: AddCommandOptions,
  services: Services,
): Promise<string> {  // Returns created task ID
  // Implementation
}
```

### Dependencies

Add `commander` to `dependencies` in `package.json`:
```json
{
  "dependencies": {
    "commander": "^12.0.0"
  }
}
```

## Testing

### Unit Tests (mocked services)

- Map CLI args to field names using config
- Apply default values from config
- Validate required fields
- Generate next ID (empty, existing, gaps)
- Trim whitespace from values
- Error on unknown fields
- Rollback storage on index failure

### Integration Tests (real services, memfs)

- Create task file and update index
- Handle custom fields from config
- All field types with defaults
- Dependencies format and circular detection

## Edge Cases

### ID Generation

- Empty directory → return "1"
- Tasks [1, 2, 3] → return "4"
- Tasks [1, 1.1, 1.2, 2] → return "3" (main IDs: 1, 2)
- Gaps [1, 3, 5] → return "6" (finds max: 5)

### Field Values

- Empty string `--title ""` → trim → treat as missing
- Whitespace only `--title "   "` → trim → treat as missing
- Multi-line: shell handles actual newlines, or use `--description "$(cat file.txt)"`
- No `\n` escape sequence parsing — literal `\n` stays as two characters

### Custom Field Validation

- CLI accepts any string value from commander.js
- No pre-validation before Parser
- Let Parser.validate()/serialize() handle type errors
- Parser errors already have clear messages

### Index Cache

- No explicit cache management in addCommand
- Index.update() handles cache internally
- No need to call load() before update()

### Dependencies

- Empty `--dependencies ""` → trim → `[]`
- Spaces `--dependencies "1, 2, 3"` → trim each → `["1", "2", "3"]`
- Duplicates `--dependencies "1,1,2"` → Index dedups
- Forward refs `--dependencies "99"` → allowed (99 may not exist yet)
- Circular → Index catches, rollback storage

### Config

- Config missing → uses built-in defaults (Title, Description, Status)
- Config corrupted → fatal error
- Config with no fields → Config validation catches this

## Exit Codes

- **0:** Success
- **1:** Error (message to stderr)

## DependsOn
4, 13

# Priority
high
