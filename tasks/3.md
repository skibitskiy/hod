# Title
Создание модуля хранилища задач (storage)

# Description
Реализовать CRUD операции для задач в файловой системе.

**Платформа:** POSIX-only (Linux, macOS). Windows не поддерживается в v1.

## StorageService

```ts
interface Task {
  id: string;
  content: string;
}

interface StorageService {
  create(id: string, content: string): Promise<void>;
  read(id: string): Promise<string>;
  update(id: string, content: string): Promise<void>;
  delete(id: string): Promise<void>;
  list(): Promise<Task[]>;
  exists(id: string): Promise<boolean>;
}
```

## Конструктор

```ts
class StorageServiceImpl implements StorageService {
  constructor(private tasksDir: string) {}
}
```

StorageService независим от ConfigService. CLI layer передаёт `tasksDir` из загруженного конфига.

**`tasksDir` — обязательный параметр.** Дефолтных значений нет.

**Валидация в конструкторе:** Не производится. Ошибки будут обнаружены при первой операции (fail-late стратегия).

## Формат ID

ID задачи — это число или числа через точку (подзадачи):
- `1` — задача
- `1.1` — подзадача задачи 1
- `1.2.3` — подзадача подзадачи
- Регулярка: `^\d+(\.\d+)*$`
- Case sensitivity не применима (только цифры и точки)

## Файлы задач

- Формат: `{tasksDir}/{id}.md`
- Примеры: `1.md`, `1.1.md`, `2.5.md`

## `.hod/` директория

- Расположение: `tasksDir/.hod/`
- Содержит: `index.json` с зависимостями
- Игнорируется во всех операциях (list, exists, read)

## Обработка ошибок

Кастомные классы:
```ts
class StorageNotFoundError extends Error {
  constructor(id: string, public cause?: Error) {
    super(`Task not found: ${id}`);
    this.name = 'StorageNotFoundError';
  }
}

class StorageWriteError extends Error {
  constructor(message: string, public cause?: Error) {
    super(message);
    this.name = 'StorageWriteError';
  }
}

class StorageAlreadyExistsError extends Error {
  constructor(id: string) {
    super(`Task already exists: ${id}`);
    this.name = 'StorageAlreadyExistsError';
  }
}

class StorageAccessError extends Error {
  constructor(message: string, public cause?: Error) {
    super(message);
    this.name = 'StorageAccessError';
  }
}
```

Error messages: пользователь-friendly на **русском языке** + технические детали в `cause`.

### Error code маппинг

**Для всех fs операций (mkdir, writeFile, unlink, rename, readdir):**
- `EACCES` → `StorageAccessError` (permissions)
- Остальное → `StorageWriteError`

**Специальные случаи:**
- `EISDIR` → `StorageAccessError` (path is directory)
- `ENOSPC` → `StorageWriteError` (no space)
- `EROFS` → `StorageAccessError` (read-only filesystem)

Нет логирования в v1.

## CRUD операция semantics

| Операция | Файл не существует | Файл существует |
|----------|-------------------|-----------------|
| `create()` | Создать файл | `StorageAlreadyExistsError` |
| `read()` | `StorageNotFoundError` | Читает (пустой файл → `''`) |
| `update()` | `StorageNotFoundError` | Атомарно обновляет |
| `delete()` | No-op (идемпотентно) | Удаляет |
| `exists()` | `false` (невалидный ID тоже `false`) | `true` |
| `list()` | `[]` (директория нет) | Список задач |

## Атомарные операции

`create()` и `update()` используют atomic write-replace (POSIX):

```ts
const tempPath = `${targetPath}.tmp`;

// Cleanup старый .tmp если есть
await fs.unlink(tempPath).catch(() => {});

await fs.writeFile(tempPath, content);
await fs.rename(tempPath, targetPath);  // atomic on POSIX
```

`create()` при EEXIST маппит в `StorageAlreadyExistsError` (race condition).

**Политика .tmp файлов:** Очищаются только перед новым create/update. Startup cleanup не нужен.

## Валидация ID

- Regex: `^\d+(\.\d+)*$`
- Максимальная длина: 50 символов
- Regex покрывает path traversal защиту (запрет `..`, `/`, `\`)
- Дополнительной sanitization не нужно

`exists()` сначала валидирует regex → возвращает `false` для невалидных ID (без filesystem access).

## Валидация content

Пустой `content` допустим (`''`). Остальная валидация — ответственность Parser модуля.

## File encoding

- UTF-8 (default Node.js `utf8`)
- Line endings определяются платформой (не сохраняем исходные)

## Symlinks

Follow symlink'и — поведение fs по умолчанию. Symlink loops вне scope v1.

## Hard links

Не определено special поведение — обрабатываются как обычные файлы.

## list() поведение

- Возвращает только `.md` файлы
- Игнорирует `.hod/` директорию
- **Пропускает файлы с невалидным ID** (не проходящими regex)
- **Пропускает недоступные файлы** (permissions) → graceful degradation
- Сортировка: numeric по сегментам
- `Task.id` без расширения (`'1'`, `'1.1'`)
- `Task.content` содержит **полный текст файла** (не preview)
- Если `tasksDir` не существует → `[]`
- Если `tasksDir` файл (не директория) → `StorageAccessError`
- Если нет прав на чтение директории → `StorageAccessError`

### Сортировка

Numeric по сегментам ID:
```ts
function sortIds(ids: string[]): string[] {
  return ids.sort((a, b) => {
    const partsA = a.split('.').map(Number);
    const partsB = b.split('.').map(Number);
    const maxLen = Math.max(partsA.length, partsB.length);
    for (let i = 0; i < maxLen; i++) {
      const valA = partsA[i] ?? 0;
      const valB = partsB[i] ?? 0;
      if (valA !== valB) return valA - valB;
    }
    return 0;
  });
}
```

Пример порядка: `1, 1.1, 1.2, 1.10, 2, 10`

## delete() поведение

- Удаляет только целевой файл `{id}.md`
- `.tmp` файлы не удаляются (технические для atomic writes)
- При `EROFS` (read-only filesystem) → `StorageAccessError`

## Создание директории

- Создаётся только при первом `create()`
- Остальные операции не создают директорию
- Если `tasksDir` файл (не директория) → `StorageAccessError`
- Игнорировать EEXIST при mkdir (race condition)

```ts
try {
  await fs.mkdir(tasksDir, { recursive: true });
} catch (e) {
  if (e.code === 'EEXIST') return;
  if (e.code === 'EACCES' || e.code === 'EROFS' || e.code === 'EISDIR') {
    throw new StorageAccessError(..., e);
  }
  throw new StorageWriteError(..., e);
}
```

## Race conditions

- **directory → file:** `StorageAccessError`
- **file → directory:** `StorageAccessError`
- **конкурентный create():** EEXIST → `StorageAlreadyExistsError`

Обрабатываются gracefully с соответствующими error классами.

## Device Full при atomic write

Если `writeFile` падает с `ENOSPC → временный файл остается. Ошибка маппится в `StorageWriteError`.

## Конкурентность

Нет file locking в v1. CLI утилита — unlikely одновременные команды.

## Лимиты

Нет ограничений на размер content в v1.

# DependsOn
2

# Priority
high
