# Title
Изменить Storage на JSON

# Description
Переделать StorageService для работы с .json файлами вместо .md.

## Overview

**Цель:** Мигрировать хранение задач из Markdown в JSON формат.

**Подход:** Dual-format поддержка с плавным переходом — Storage умеет читать и `.md`, и `.json`, но новые задачи создаются в JSON.

**Interface:** Без изменений — `StorageService` принимает/возвращает строки, только формат содержимого меняется.

---

## Interface (сохраняется)

```ts
interface Task {
  id: string;
  content: string;  // было: markdown, станет: JSON string
}

interface StorageService {
  create(id: string, content: string): Promise<void>;
  read(id: string): Promise<string>;
  update(id: string, content: string): Promise<void>;
  delete(id: string): Promise<void>;
  list(): Promise<Task[]>;
  exists(id: string): Promise<boolean>;
}
```

---

## Data Flow

```
CLI команда
    ↓
Parser.parseJson(content) → ParsedTask
    ↓
Бизнес-логика (фильтрация, валидация)
    ↓
Parser.serializeToJson(task) → JSON string (pretty-printed)
    ↓
Storage.create(id, jsonString)
    ↓
{id}.json файл на диске
```

**Ключевой принцип:** Parser знает про JSON формат и делает pretty-printing. Storage только валидирует syntax и проверяет тип.

---

## JSON Schema

Формат файла задачи соответствует `ParsedTask` + кастомные поля из `config.fields`:

```json
{
  "title": "string (required)",
  "description": "string (optional)",
  "customfield": "string (lowercase, из config.fields)"
}
```

**Правила:**
- **Status** и **dependencies** хранятся в индексе (`.hod/index.json`), не в файле задачи
- Кастомные поля всегда в **lowercase** (как ключи в ParsedTask)
- Пустые опциональные поля опускаются (не `null`)
- Pretty-printed с 2 пробелами

---

## Dual Format Support

Storage умеет работать с обоими форматами для плавной миграции:

| Метод | Поведение |
|-------|-----------|
| `list()` | Сканирует `.json` и `.md`, prefer `.json`, дедуплицирует ID, игнорирует `.tmp` |
| `read(id)` | Алгоритм ниже (JSON priority, fail-fast) |
| `exists(id)` | Возвращает `true` если `.json` ИЛИ `.md` существует (игнорирует `.tmp`) |
| `create` | Создает `.json`, валидирует + pretty-print |
| `update` | Создает `.json`, удаляет `.md` при успехе |
| `delete` | Удаляет оба `.json` И `.md` если существуют |

### Алгоритм `read(id)`

```
1. Try {id}.json
   - missing → step 2
   - malformed JSON → StorageParseError (NO fallback, fail-fast)
   - valid → return content

2. Try {id}.md
   - missing → StorageNotFoundError
   - valid → return content
```

**Q: Почему fail-fast для corrupted JSON?**
**A:** Explicit error лучше чем silent fallback. Corrupted JSON — это data corruption которая должна быть заметна.

---

## Serialization (Parser)

Parser получает новые методы, старые остаются для `--markdown` флага:

```ts
// Новые методы для JSON
parser.serializeToJson(task: ParsedTask): string
parser.parseJson(jsonString: string): ParsedTask

// Старые методы для markdown (для --markdown флага в get)
parser.serialize(task: ParsedTask): string
parser.parse(markdown: string): ParsedTask
```

**Ответственность разделения:**
- **Parser** — ParsedTask ↔ JSON/Markdown, знает про структуру данных
- **Storage** — файловые операции + JSON syntax validation, не знает про ParsedTask
- **Consumers** — вызывают нужный метод Parser

**Q: Должен ли `Parser.parseJson()` enforce те же constraints что `parse()` для markdown?**
**A:** Да — reject non-string custom fields (как markdown). Consistency с данными.

**Q: Должен ли `Parser.serializeToJson()` drop пустые опциональные поля?**
**A:** Да — опускает `description: ""`, `custom: ""` (как markdown). Smaller files, cleaner diffs.

**Q: Должен ли `Parser.serializeToJson()` валидировать типы кастомных полей?**
**A:** Да — throw если custom field не string. Type safety.

**Q: В каком формате сохранять кастомные поля в JSON?**
**A:** Lowercase (как ключи в ParsedTask). Config использует kebab-case для CLI, но в JSON — lowercase.

---

## Validation & Error Handling

### JSON Validation в Storage

| Операция | Валидация | Ошибка |
|----------|-----------|--------|
| `create()` | Private `validateJson()` — syntax + object type check | `StorageWriteError` |
| `update()` | Private `validateJson()` — syntax + object type check | `StorageWriteError` |
| `read()` | Валидирует syntax после чтения, malformed → `StorageParseError` | `StorageParseError` |

**validateJson(content: string): void** (private helper):
```ts
// 1. JSON.parse() для syntax check
// 2. typeof parsed === 'object' && parsed !== null && !Array.isArray(parsed)
// Throws: StorageWriteError с деталями
```

**Q: Какой уровень валидации должен выполнять `read()`?**
**A:** Syntax validation только. Если JSON malformed → `StorageParseError` с позицией ошибки.

**Q: Как `create()/update()` обрабатывают валидный JSON но не объект?**
**A:** Reject с ошибкой (только plain objects `{...}`). Предотвращает data corruption.

**Q: Должен ли Storage pretty-print JSON?**
**A:** Нет — Parser уже делает pretty-print в `serializeToJson()`. Storage только проверяет syntax.

### Scope валидации

| Слой | Ответственность |
|------|-----------------|
| **Storage** | JSON syntax + проверка что это object (не null/array/primitive) |
| **Parser** | Структура, типы полей, required fields, lowercase keys |
| **Consumers** | Бизнес-логика (валидация ID, зависимостей, etc.) |

### StorageParseError

```ts
export class StorageParseError extends StorageError {
  constructor(
    message: string,
    public readonly fileId: string,
    public readonly parseMessage: string,  // JSON.parse сообщение
    public readonly position?: string,      // "at position X" или line/column
  ) { super(message); }
}
```

**Q: В каком формате должен быть `position`?**
**A:** "at position X" из нативного `JSON.parse()` (простой и deterministic).

**Q: На каком языке сообщения?**
**A:** Русский (consistent с проектом).

---

## Edge Cases

| Ситуация | Поведение |
|----------|-----------|
| Extra поля в JSON | Parser сохраняет в `parseJson()`, теряет в `serializeToJson()` |
| Wrong types (`title: 42`) | Storage не валидирует, Parser reject при `parseJson()` |
| Concurrent writes | POSIX atomic rename (last write wins) |
| `.json` + `.md` оба | `.json` priority, `.md` ignored для read/list |
| Corrupted `.json` | `StorageParseError`, NO fallback на `.md` (fail-fast) |
| `.json.tmp` файлы | Игнорируются в `list()` и `exists()` |
| Race conditions | Accept inconsistency (POSIX semantics, single-user CLI) |

**Q: Как обрабатывать race condition между проверкой формата и чтением?**
**A:** Игнорировать — POSIX filesystem semantics accept TOCTOU race conditions. Single-user CLI.

---

## Implementation Changes

### 1. storage.ts

**Файловые операции:**
- Расширения: `.json` (новые), `.md` (legacy для чтения)
- Временные: `.json.tmp` (игнорируются в `list`/`exists`)
- `list()`: сканирует оба формата, prefer `.json`, дедуплицирует ID
- `read(id)`: алгоритм выше (JSON priority, fail-fast для corrupted)
- `exists(id)`: `.json` ИЛИ `.md` (но не `.tmp`)
- `delete(id)`: удалить оба если существуют

**Валидация (private helper):**
```ts
private validateJson(content: string): void {
  try {
    const parsed = JSON.parse(content);
    if (parsed === null || typeof parsed !== 'object' || Array.isArray(parsed)) {
      throw new StorageWriteError('JSON должен быть объектом');
    }
  } catch (e) {
    if (e instanceof SyntaxError) {
      throw new StorageWriteError(`Невалидный JSON: ${e.message}`);
    }
    throw e;
  }
}
```

**create(id, content):**
1. `validateJson(content)`
2. `writeFile({id}.json.tmp, content)`
3. `rename({id}.json.tmp → {id}.json)`

**update(id, content):**
1. `validateJson(content)`
2. `writeFile({id}.json.tmp, content)`
3. `rename({id}.json.tmp → {id}.json)`
4. При успехе: `unlink({id}.md)` если существует

**read(id):**
1. Try `readFile({id}.json)`
   - ENOENT → step 2
   - SyntaxError → `StorageParseError` (NO fallback)
   - Success → return content
2. Try `readFile({id}.md)`
   - ENOENT → `StorageNotFoundError`
   - Success → return content

### 2. storage/errors.ts

```ts
export class StorageParseError extends StorageError {
  constructor(
    message: string,
    public readonly fileId: string,
    public readonly parseMessage: string,
    public readonly position?: string,
  ) { super(message); }
}
```

### 3. parser.ts (задачи 4.3-4.6)

```ts
// Сериализует ParsedTask в JSON string
// - Drop пустые опциональные поля
// - Валидирует что кастомные поля === string
// - Pretty-printed с 2 пробелами
// - Ключи в lowercase (как в ParsedTask)
serializeToJson(task: ParsedTask): string

// Парсит JSON string в ParsedTask
// - Валидирует типы полей (title: string required)
// - Reject non-string custom fields
// - Сохраняет unknown fields (теряются при serializeToJson)
parseJson(jsonString: string): ParsedTask
```

### 4. CLI команды (задачи 4.3-4.6)

| Команда | Изменение |
|---------|-----------|
| **add** | `parser.serializeToJson()` вместо `serialize()` |
| **get** | `parser.parseJson()` вместо `parse()` (старый для `--markdown`) |
| **update** | `parser.parseJson()` для чтения, `serializeToJson()` для записи |
| **list** | `parser.parseJson()` вместо `parse()` |

---

## Testing

### Unit tests (storage)
- `create()/update()` с invalid JSON, null, array, primitives
- `read()` с malformed JSON → `StorageParseError`
- `read()` с missing `.json` → fallback на `.md`
- `list()` с `.json` + `.md` дубликатами → prefer `.json`
- `list()` игнорирует `.json.tmp`
- `exists()` с `.json`, `.md`, `.tmp`
- `delete()` удаляет оба формата
- `update()` удаляет `.md` при успехе

### Unit tests (parser)
- `serializeToJson()` drop пустых полей
- `serializeToJson()` валидирует типы кастомных полей
- `parseJson()` reject non-string custom fields
- `parseJson()` сохраняет unknown fields

### Property-based tests
- Round-trip: `parseJson(serializeToJson(task)) === task`
- Special characters: newline, tabs, quotes, unicode, emojis
- Unknown fields: сохраняются→теряются

### Integration tests
- CLI команды с JSON данными
- Migration: `.md` → `.json` при update
- Corrupted JSON detection

---

## Migration Path

1. **Task 4.2:** Storage с dual-format support
2. **Tasks 4.3-4.6:** CLI команды используют JSON методы
3. **Task 4.7:** Migration команда для bulk `.md` → `.json`

**Backward compatibility:** Существующие `.md` файлы продолжают работать.

---

# status
pending
